{"version":3,"file":"js/634.475d8fc0.js","mappings":"8TACOA,MAAM,W,GACTC,EAAAA,EAAAA,GAAoC,YAAhCA,EAAAA,EAAAA,GAA2B,YAArB,oBAAV,G,GACKD,MAAM,a,ugDA6CJA,MAAM,Y,GACTC,EAAAA,EAAAA,GAAgC,KAA7BD,MAAM,YAAW,YAAQ,G,GACvBA,MAAM,Q,GACTC,EAAAA,EAAAA,GAAmD,SAAhD,gDAA4C,G,GAU/CA,EAAAA,EAAAA,GAII,mBAJD,8DAEDA,EAAAA,EAAAA,GAAI,OAEF,QAFE,iEACJA,EAAAA,EAAAA,GAAI,OACF,QADE,uBAHN,G,GAOCD,MAAM,Y,GACTC,EAAAA,EAAAA,GAAmC,KAAhCD,MAAM,YAAW,eAAW,G,GAC1BA,MAAM,Q,qiDArEjBE,EAAAA,EAAAA,IAgIM,MAhIN,EAgIM,CA/HJC,GACAF,EAAAA,EAAAA,GA6HM,MA7HN,EA6HM,CA5HJG,GA4CAH,EAAAA,EAAAA,GAmBM,MAnBN,EAmBM,CAlBJI,GACAJ,EAAAA,EAAAA,GAgBM,MAhBN,EAgBM,CAfJK,GACAC,EAAAA,EAAAA,IAQcC,EAAA,CAPXC,MAAMC,EAAAA,eAAc,GACpBC,UAAW,CAAC,CAAC,OAAQ,SACrBC,WAAW,EACXC,aAAa,EACbC,WAAW,EACZC,MAAM,OACNC,UAAU,QAPZ,kBASAC,OAOJhB,EAAAA,EAAAA,GAiDM,MAjDN,EAiDM,CAhDJiB,GACAjB,EAAAA,EAAAA,GA8CM,MA9CN,EA8CM,CA7CJkB,GAoCAZ,EAAAA,EAAAA,IAQcC,EAAA,CAPXC,MAAMC,EAAAA,eAAc,GACpBC,UAAW,CAAC,CAAC,OAAQ,SACrBC,WAAW,EACXC,aAAa,EACbC,WAAW,EACZC,MAAM,OACNC,UAAU,QAPZ,sBAWJI,M,cAgBN,MAAMC,EAAiB,CACvB,sRAuBA,gxCAoDA,OACEC,KAAM,YACNC,MAAO,GAEPC,WAAY,CACVC,WAAUA,EAAAA,GAEZC,OACE,MAAM,CACJL,oB,QCtNN,MAAMM,GAA2B,OAAgB,EAAQ,CAAC,CAAC,SAASC,KAEpE","sources":["webpack://jbc_test/./src/views/pages/note/about.vue","webpack://jbc_test/./src/views/pages/note/about.vue?c569"],"sourcesContent":["<template>\r\n  <div class=\"section\">\r\n    <h3><span>Vue.js의 개념과 특징</span></h3>\r\n    <div class=\"info_wrap\">\r\n      <h4><i class=\"fa-brands fa-vuejs\"></i>Vue의 개념</h4>\r\n      <div class=\"info_box\">\r\n        <p class=\"info_tit\">Vue.js 란?</p>\r\n        <div class=\"info\">\r\n          <p>Evan You가 만들었으며, 2014년 릴리즈를 시작으로 꾸준히 발전하고 있는 JS 프레임워크.<br> 컨트롤러 대신 뷰 모델을 가지는 MVVM(Model-View-ViewModel) 패턴을 기반으로 디자인되었으며,\r\n          재사용이 가능한 UI들을 묶어서 사용함.</p>\r\n\r\n        </div>\r\n      </div>\r\n      <div class=\"info_box\">\r\n        <p class=\"info_tit\">Vue.js 호환성</p>\r\n        <div class=\"info\">          \r\n          <p>ES5에서 새로 등장한 기능이라 IE8 이하 버전은 미지원</p>\r\n          <div class=\"img_box\"><img src=\"@/assets/img/compatibility.png\" alt=\"호환성이미지\"><span>출처 : https://itcoach.tistory.com/18</span></div>\r\n        </div>\r\n      </div>\r\n      <div class=\"info_box\">\r\n        <p class=\"info_tit\">Vue.js 특징</p>\r\n        <div class=\"info\">\r\n          <ul>\r\n            <li>MVVM 패턴을 사용</li>\r\n            <li>Angular에서 지원하는 양방향 데이터 바인딩을 동일하게 제공 (단,컴포넌트 간 통신은 단방향 흐름)</li>\r\n            <li>Angular, React에 비해 매우 작고 가벼우며 복잡도가 낮음</li>\r\n            <li>Template과 Componenet를 사용하여 재사용이 가능한 사용자 인터페이스를 묶고 View Layer를 정리하여 사용</li>        \r\n          </ul>\r\n        </div>\r\n      </div>\r\n      <div class=\"info_box\">\r\n        <p class=\"info_tit\">MVVM 패턴</p>\r\n        <div class=\"info\">\r\n          <div class=\"img_box\"><img src=\"@/assets/img/mvvm.png\" alt=\"mvvm 모델 이미지\"></div>\r\n          <p>MVVM (Modal - View - ViewModel) 패턴이란? <br> 마크업 언어나 GUI코드를 비즈니스 로직 or 백엔드 로직과 분리하여 개발하는 소프트웨어 디자인 패턴이다.</p>\r\n          <p>즉, 프론트엔드의 화면 로직과 백엔드 데이터 처리 로직을 분리하여 깔끔하게 코드를 구성하게 됨.</p>\r\n        </div>\r\n      </div>\r\n      <div class=\"info_box\">\r\n        <p class=\"info_tit\">컴포넌트 기반 프레임워크</p>\r\n        <div class=\"info\">\r\n          <div class=\"img_box\"><img src=\"@/assets/img/component.png\" alt=\"컴포넌트 형식 이미지\"><span>출처 : https://jocoma.tistory.com/entry/Vue-Componets</span></div>\r\n          <p>최신 프론트엔드 프레임워크는 전부다 컴포넌트 기반의 개발 방식을 추구하고 있다.</p>\r\n          <p>왼쪽 그림은 유저에게 보여지는 화면단이며, 오른쪽은 화면단의 컴포넌트 구조형식을 표현한 그림이다.</p>\r\n          <p>이런식으로 화면의영역을 컴포넌트로 쪼개서 재활용할 수 있는 형태로 만들어 관리 및 수정이 편리하다.</p>\r\n        </div>\r\n      </div>\r\n      <div class=\"info_box\">\r\n        <p class=\"info_tit\">vue 인스턴스</p>       \r\n        <div class=\"info\">\r\n          <p>인스턴스는 개발하기위해 필수적으로 생성해야하는 기본 단위로 코드는 다음과 같다.</p>\r\n          <CodeEditor\r\n            :value=codeEditorList[0]\r\n            :languages=\"[['html', 'HTML']]\"\r\n            :read_only=\"true\"\r\n            :hide_header=\"true\"\r\n            :wrap_code=\"true\"\r\n            width=\"100%\"\r\n            font_size=\"14px\"\r\n          ></CodeEditor>\r\n          <p>\r\n            CDN이 아닌 NPM으로 Vue를 생성했다면 Vue페이지 내에 스크립트로 인스턴스가 자동 생성된다.\r\n            <br>이처럼 기본 인스턴스에서 상태에 따라 호출할 수 있는 속성들이 존재하는데 이를 라이플 사이클이라고 부른다.\r\n            <br>라이플 사이클은 다음과 같다.\r\n          </p>\r\n        </div>\r\n      </div>\r\n      <div class=\"info_box\">\r\n        <p class=\"info_tit\">vue 라이프 사이클</p>\r\n        <div class=\"info\">     \r\n          <div class=\"img_box\"><img src=\"@/assets/img/lifecycle.png\" alt=\"컴포넌트 형식 이미지\"><span>출처 : https://joshua1988.github.io/vue-camp/vue/life-cycle.html</span></div>\r\n          <ul>\r\n            <li><span>beforeCreate()</span> \r\n              <p>인스턴스가 방금 초기화됨.</p>\r\n              <p>* 데이터와 이벤트들(vm.$on, vm.$once, vm.$off 등)이 설정되지 않아, 접근할 수 없음</p> \r\n            </li>\r\n            <li><span>created()</span>\r\n              <p>인스턴스 작성 후 동기적으로 호출.</p>\r\n              <p>* 데이터, 속성, 메서드, 이벤트 콜백 등과 같은 옵션 처리를 완료. 단 돔접근x</p>\r\n            </li> \r\n            <li><span>beforeMount()</span> \r\n              <p>마운트 시작되기 바로 전에 호출.</p>\r\n              <p> * render 함수의 첫 호출</p>\r\n            </li>\r\n            <li><span>mounted()</span>  \r\n              <p>인스턴스가 마운트 된 직후 호출.</p>\r\n              <p>* 컴포넌트, 템플릿, 렌더링된 DOM에 접근 할 수 있음</p>\r\n            </li>\r\n            <li><span>beforeUpdate()</span> \r\n              <p>컴포넌트의 데이터가 변하여 업데이트사이클이 시작될 때 실행.</p>\r\n              <p>* 정확히는 DOM이 패치되기 전 데이터가 변경될 때 호출</p>\r\n            </li>\r\n            <li><span>updated()</span>\r\n              <p>데이터가 변경되어 가상 DOM이 재렌더링되고 패치된 후에 호출.</p>\r\n              <p>* updated가 호출될 때 컴포넌트의 DOM이 업데이트되므로 여기서 DOM의 종속적인 연산가능</p>\r\n              <p>* 단 무한루프 빠질 수 있으니 데이터 변경은 그 전 단계에서 하는게 좋음</p>\r\n            </li>\r\n            <li><span>beforeDestroy()</span>\r\n              <p>Vue 인스턴스가 제거되기 전에 실행. 컴포넌트는 원래 모습과 원래 기능들을 가지고 있음.</p>\r\n              <p>* 이벤트 리스너나 subscription? 제거에 사용하면 좋음.</p>\r\n            </li>\r\n            <li><span>destroyed()</span>\r\n              <p>Vue 인스턴스 제거 후에 실행. 모든 인스턴스와 디렉티브가 바인딩 해제되고, 모든 이벤트들이 제거됨.</p>\r\n              <p>* 하위 Vue 인스턴스도 제거됨.</p>\r\n            </li>       \r\n          </ul>\r\n          <CodeEditor\r\n            :value=codeEditorList[1]\r\n            :languages=\"[['html', 'HTML']]\"\r\n            :read_only=\"true\"\r\n            :hide_header=\"true\"\r\n            :wrap_code=\"true\"\r\n            width=\"100%\"\r\n            font_size=\"14px\"\r\n          ></CodeEditor>\r\n        </div>\r\n      </div>\r\n      <div class=\"info_box\">\r\n        <p class=\"info_tit\">참고 사이트</p>\r\n        <div class=\"info\">\r\n          <div class=\"link_wrap\">\r\n            <a href=\"https://wikidocs.net/17701\" target=\"_blank\">Vue란?</a>\r\n            <a href=\"https://kr.vuejs.org/v2/guide/index.html\" target=\"_blank\">Vue 시작하기</a>\r\n            <a href=\"https://v3-docs.vuejs-korea.org/guide/introduction.html\" target=\"_blank\">Vue.js 공식문서</a>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport CodeEditor from 'simple-code-editor';\r\nconst codeEditorList = [\r\n`\r\n<template>\r\n  <div class=\"test\">\r\n    <h1>{{message}}</h1>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\n  //아래부분이 인스턴스 기본구조\r\n  /*new Vue({})로 쓰이기도 함.*/\r\nexport default {\r\n  name: '',\r\n  data:{\r\n    message:'데이터넣기',\r\n  },\r\n  components: {\r\n  },\r\n  methods: {\r\n  },\r\n}\r\n<${'/'}script>\r\n`\r\n,\r\n`\r\n<template>\r\n  <h1 id='h1'>{{ message }}</h1>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  data() {\r\n    return {\r\n      message : 'hello' ,\r\n    }\r\n  },  \r\n  //순서대로 실행된다.\r\n\r\n  beforeCreate() {         \r\n    // beforeCreate() - 초기단계로 data와 methods 정의되지않은 상태                   \r\n    console.log('Before Create 속성',this.message) \r\n    //결과: Before Create속성 , undefined \r\n  },\r\n\r\n  created() {\r\n    //created() - data와 methods 속성 접근가능\r\n    console.log('Created 속성',this.message)      \r\n    //결과 : Created 속성,hello  - 생선된 직후라 데이터 로직 받아짐.\r\n    console.log(document.getElementById('h1'))  \r\n    //결과 : null -인스턴스가 화면단에 넣기 전이라 돔요소 못찾음.\r\n  },\r\n\r\n  beforeMount() {\r\n    //beforeMount() - render()함수 변환 후 요소 부착전 상태 ..?\r\n    console.log('BeforeMount')//잘나옴 \r\n    console.log(document.getElementById('h1'))   \r\n    //null - 속성 확인 후 돔 삽입 전 상태라서 null \r\n  },\r\n    mounted() {\r\n    // mounted() - 화면요소에 인스턴스 부착후 단계\r\n    console.log('Mounted')//잘나옴\r\n    this.message = '데이터변경'; \r\n    //인스턴스 부착되자마자 호출되어서 여기부터 데이터 변경가능\r\n    //단 하위컴포넌트나 외부라이브러리에 의해 추가된 것들은 안됨.\r\n    console.log(document.getElementById('h1'))       \r\n    //<h1>데이터변경</h1>\r\n  },\r\n  updated(){\r\n    //이부분 부터 데이터치환,화면제어요소 등 다 사용가능\r\n    //단 여기서 데이터값을 변경하면 무한루프에 빠진다고함.\r\n    // 데이터 변경은 mounted()나 beforeUpdate() 사이클에서 하는게 좋음.\r\n  },\r\n}\r\n<${'/'}script>\r\n`\r\n]\r\nexport default {\r\n  name: 'about-App',\r\n  props: {\r\n  },\r\n  components: {\r\n    CodeEditor\r\n  },\r\n  data(){\r\n    return{\r\n      codeEditorList\r\n    }\r\n  }\r\n}\r\n</script>","import { render } from \"./about.vue?vue&type=template&id=4dc66bb9\"\nimport script from \"./about.vue?vue&type=script&lang=js\"\nexport * from \"./about.vue?vue&type=script&lang=js\"\n\nimport exportComponent from \"C:\\\\Users\\\\삼도리\\\\Desktop\\\\publish\\\\jbc\\\\jbc_vue_practice\\\\node_modules\\\\vue-loader\\\\dist\\\\exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render]])\n\nexport default __exports__"],"names":["class","_createElementVNode","_createElementBlock","_hoisted_2","_hoisted_4","_hoisted_11","_hoisted_13","_createVNode","_component_CodeEditor","value","$data","languages","read_only","hide_header","wrap_code","width","font_size","_hoisted_14","_hoisted_16","_hoisted_18","_hoisted_20","codeEditorList","name","props","components","CodeEditor","data","__exports__","render"],"sourceRoot":""}